// This property file was autogenerated by AutoCC on 2024-11-25
// to check the behavior of the original RTL module, whose interface is described below: 

module axi_xslv_prop
import cf_math_pkg::idx_width;
#(
		parameter ASSERT_INPUTS = 0,
		parameter                                              axi_pkg::xbar_cfg_t Cfg = '0,
		parameter bit                                          ATOPs = 1'b1,
		parameter bit [Cfg.NoSlvPorts-1:0][Cfg.NoMstPorts-1:0] Connectivity = '1,
		parameter type                                         slv_aw_chan_t = logic,
		parameter type                                         mst_aw_chan_t = logic,
		parameter type                                         w_chan_t = logic,
		parameter type                                         slv_b_chan_t = logic,
		parameter type                                         mst_b_chan_t = logic,
		parameter type                                         slv_ar_chan_t = logic,
		parameter type                                         mst_ar_chan_t = logic,
		parameter type                                         slv_r_chan_t = logic,
		parameter type                                         mst_r_chan_t = logic,
		parameter type                                         slv_req_t = logic,
		parameter type                                         slv_resp_t = logic,
		parameter type                                         mst_req_t = logic,
		parameter type                                         mst_resp_t = logic,
		parameter type                                         rule_t = axi_pkg::xbar_rule_64_t
) (
		/// Clock, positive edge triggered.
		input logic                                                     clk_i,
		/// Asynchronous reset, active low.  
		input logic                                                     rst_ni,
		/// Testmode enable, active high.
		input logic                                                     test_i,
		/// AXI4+ATOP requests to the slave ports.  
		input                                                           slv_req_t [Cfg.NoSlvPorts-1:0] slv_ports_req_i_2,
		input                                                           slv_req_t [Cfg.NoSlvPorts-1:0] slv_ports_req_i,
		/// AXI4+ATOP responses of the slave ports.  
		input                                                           slv_resp_t [Cfg.NoSlvPorts-1:0] slv_ports_resp_o_2,
		input                                                           slv_resp_t [Cfg.NoSlvPorts-1:0] slv_ports_resp_o, //output
		/// Address map array input for the crossbar. This map is global for the whole module.
		/// It is used for routing the transactions to the respective master ports.
		/// Each master port can have multiple different rules.
		input                                                           rule_t [Cfg.NoAddrRules-1:0] addr_map_i,
		/// Enable default master port.
		input logic [Cfg.NoSlvPorts-1:0]                                en_default_mst_port_i,
		`ifdef VCS
		/// Enables a default master port for each slave port. When this is enabled unmapped
		/// transactions get issued at the master port given by `default_mst_port_i`.
		/// When not used, tie to `'0`.  
		input logic [Cfg.NoSlvPorts-1:0][MstPortsIdxWidth-1:0]          default_mst_port_i
		`else
		/// Enables a default master port for each slave port. When this is enabled unmapped
		/// transactions get issued at the master port given by `default_mst_port_i`.
		/// When not used, tie to `'0`.  
		input logic [Cfg.NoSlvPorts-1:0][idx_width(Cfg.NoMstPorts)-1:0] default_mst_port_i
		`endif
	);

//==============================================================================
// Local Parameters
//==============================================================================

genvar j;
default clocking cb @(posedge clk_i);
endclocking
default disable iff (!rst_ni);

// Re-defined wires 
wire slv_port_r_req_0_val;
wire slv_port_r_req_0__2_val;
wire slv_port_r_req_0_rdy;
wire slv_port_r_req_0__2_rdy;
wire slv_port_r_req_0_transid;
wire slv_port_r_req_0__2_transid;
wire slv_port_r_resp_0_val;
wire slv_port_r_resp_0__2_val;
wire slv_port_r_resp_0_rdy;
wire slv_port_r_resp_0__2_rdy;
wire slv_port_r_resp_0_transid;
wire slv_port_r_resp_0__2_transid;
wire slv_port_r_req_1_val;
wire slv_port_r_req_1__2_val;
wire slv_port_r_req_1_rdy;
wire slv_port_r_req_1__2_rdy;
wire slv_port_r_req_1_transid;
wire slv_port_r_req_1__2_transid;
wire slv_port_r_resp_1_val;
wire slv_port_r_resp_1__2_val;
wire slv_port_r_resp_1_rdy;
wire slv_port_r_resp_1__2_rdy;
wire slv_port_r_resp_1_transid;
wire slv_port_r_resp_1__2_transid;
wire slv_port_w_req_0_val;
wire slv_port_w_req_0__2_val;
wire slv_port_w_req_0_rdy;
wire slv_port_w_req_0__2_rdy;
wire slv_port_w_req_0_transid;
wire slv_port_w_req_0__2_transid;
wire slv_port_w_resp_0_val;
wire slv_port_w_resp_0__2_val;
wire slv_port_w_resp_0_rdy;
wire slv_port_w_resp_0__2_rdy;
wire slv_port_w_resp_0_transid;
wire slv_port_w_resp_0__2_transid;
wire slv_port_w_req_1_val;
wire slv_port_w_req_1__2_val;
wire slv_port_w_req_1_rdy;
wire slv_port_w_req_1__2_rdy;
wire slv_port_w_req_1_transid;
wire slv_port_w_req_1__2_transid;
wire slv_port_w_resp_1_val;
wire slv_port_w_resp_1__2_val;
wire slv_port_w_resp_1_rdy;
wire slv_port_w_resp_1__2_rdy;
wire slv_port_w_resp_1_transid;
wire slv_port_w_resp_1__2_transid;

// Symbolics and Handshake signals
wire slv_port_r_req_0_hsk = slv_port_r_req_0_val && slv_port_r_req_0_rdy;
wire slv_port_r_resp_0_hsk = slv_port_r_resp_0_val && slv_port_r_resp_0_rdy;
wire [0:0] symb_slv_port_r_req_0_transid;
am__symb_slv_port_r_req_0_transid_stable: assume property($stable(symb_slv_port_r_req_0_transid));
wire slv_port_r_req_0__2_hsk = slv_port_r_req_0__2_val && slv_port_r_req_0__2_rdy;
wire slv_port_r_resp_0__2_hsk = slv_port_r_resp_0__2_val && slv_port_r_resp_0__2_rdy;
wire [0:0] symb_slv_port_r_req_0__2_transid;
am__symb_slv_port_r_req_0__2_transid_stable: assume property($stable(symb_slv_port_r_req_0__2_transid));
wire slv_port_r_req_1_hsk = slv_port_r_req_1_val && slv_port_r_req_1_rdy;
wire slv_port_r_resp_1_hsk = slv_port_r_resp_1_val && slv_port_r_resp_1_rdy;
wire [0:0] symb_slv_port_r_req_1_transid;
am__symb_slv_port_r_req_1_transid_stable: assume property($stable(symb_slv_port_r_req_1_transid));
wire slv_port_r_req_1__2_hsk = slv_port_r_req_1__2_val && slv_port_r_req_1__2_rdy;
wire slv_port_r_resp_1__2_hsk = slv_port_r_resp_1__2_val && slv_port_r_resp_1__2_rdy;
wire [0:0] symb_slv_port_r_req_1__2_transid;
am__symb_slv_port_r_req_1__2_transid_stable: assume property($stable(symb_slv_port_r_req_1__2_transid));
wire slv_port_w_req_0_hsk = slv_port_w_req_0_val && slv_port_w_req_0_rdy;
wire slv_port_w_resp_0_hsk = slv_port_w_resp_0_val && slv_port_w_resp_0_rdy;
wire [0:0] symb_slv_port_w_req_0_transid;
am__symb_slv_port_w_req_0_transid_stable: assume property($stable(symb_slv_port_w_req_0_transid));
wire slv_port_w_req_0__2_hsk = slv_port_w_req_0__2_val && slv_port_w_req_0__2_rdy;
wire slv_port_w_resp_0__2_hsk = slv_port_w_resp_0__2_val && slv_port_w_resp_0__2_rdy;
wire [0:0] symb_slv_port_w_req_0__2_transid;
am__symb_slv_port_w_req_0__2_transid_stable: assume property($stable(symb_slv_port_w_req_0__2_transid));
wire slv_port_w_req_1_hsk = slv_port_w_req_1_val && slv_port_w_req_1_rdy;
wire slv_port_w_resp_1_hsk = slv_port_w_resp_1_val && slv_port_w_resp_1_rdy;
wire [0:0] symb_slv_port_w_req_1_transid;
am__symb_slv_port_w_req_1_transid_stable: assume property($stable(symb_slv_port_w_req_1_transid));
wire slv_port_w_req_1__2_hsk = slv_port_w_req_1__2_val && slv_port_w_req_1__2_rdy;
wire slv_port_w_resp_1__2_hsk = slv_port_w_resp_1__2_val && slv_port_w_resp_1__2_rdy;
wire [0:0] symb_slv_port_w_req_1__2_transid;
am__symb_slv_port_w_req_1__2_transid_stable: assume property($stable(symb_slv_port_w_req_1__2_transid));

localparam THRESHOLD = 3;
reg [$clog2(THRESHOLD):0] equal_cnt;
wire transfer_cond;
reg spy_mode; //Set when the equal_cnt reaches THRESHOLD
wire spy_starts = transfer_cond && equal_cnt >= THRESHOLD;
wire flush_done; //Set free by default (anytime) USER may set the conditions that indicate the flush has finished for both universes.
always_ff @(posedge clk_i) begin
	if (!rst_ni) begin
		spy_mode   <= '0;
		equal_cnt  <= '0;
	end else begin
		spy_mode <= spy_starts || spy_mode;
		equal_cnt <= (flush_done || equal_cnt>0) && transfer_cond ? equal_cnt + 1 : '0;
	end
end

// There is an assertion per output signal from the DUT
as__slv_ports_resp_o: assert property (spy_mode |-> (slv_ports_resp_o == slv_ports_resp_o_2));

// There is an assumption per input signal to the DUT
am__slv_ports_req_i: assume property (spy_mode |-> (slv_ports_req_i == slv_ports_req_i_2));

assign io_equal = slv_ports_req_i == slv_ports_req_i_2 &&
 slv_ports_resp_o == slv_ports_resp_o_2 &&
1'b1;
// The USER includes conditions here based on the architectural state of the DUT
wire architectural_state_eq;
// Conjunction of all conditions that need to be met before starting to check 
assign transfer_cond = architectural_state_eq && io_equal;
//==============================================================================
// Modeling
//==============================================================================

// Modeling incoming request for slv_port_r_req_0
if (ASSERT_INPUTS) begin
	as__slv_port_r_req_0_fairness: assert property (slv_port_r_resp_0_val |-> s_eventually(slv_port_r_resp_0_rdy));
end else begin
	am__slv_port_r_req_0_fairness: assume property (slv_port_r_resp_0_val |-> s_eventually(slv_port_r_resp_0_rdy));
end

// Generate sampling signals and model
reg [3:0] slv_port_r_req_0_transid_sampled;
wire slv_port_r_req_0_transid_set = slv_port_r_req_0_hsk && slv_port_r_req_0_transid == symb_slv_port_r_req_0_transid;
wire slv_port_r_req_0_transid_response = slv_port_r_resp_0_hsk && slv_port_r_resp_0_transid == symb_slv_port_r_req_0_transid;

always_ff @(posedge clk_i) begin
	if(!rst_ni) begin
		slv_port_r_req_0_transid_sampled <= '0;
	end else if (slv_port_r_req_0_transid_set || slv_port_r_req_0_transid_response ) begin
		slv_port_r_req_0_transid_sampled <= slv_port_r_req_0_transid_sampled + slv_port_r_req_0_transid_set - slv_port_r_req_0_transid_response;
	end
end
co__slv_port_r_req_0_transid_sampled: cover property (|slv_port_r_req_0_transid_sampled);
if (ASSERT_INPUTS) begin
	as__slv_port_r_req_0_transid_sample_no_overflow: assert property (slv_port_r_req_0_transid_sampled != '1 || !slv_port_r_req_0_transid_set);
end else begin
	am__slv_port_r_req_0_transid_sample_no_overflow: assume property (slv_port_r_req_0_transid_sampled != '1 || !slv_port_r_req_0_transid_set);
end


// Assert that if valid eventually ready or dropped valid
//as__slv_port_r_req_0_transid_hsk_or_drop: assert property (slv_port_r_req_0_val |-> s_eventually(!slv_port_r_req_0_val || slv_port_r_req_0_rdy));
// Assert that every request has a response and that every reponse has a request
//as__slv_port_r_req_0_transid_eventual_response: assert property (|slv_port_r_req_0_transid_sampled |-> s_eventually(slv_port_r_resp_0_val && (slv_port_r_resp_0_transid == symb_slv_port_r_req_0_transid) ));
//as__slv_port_r_req_0_transid_was_a_request: assert property (slv_port_r_req_0_transid_response |-> slv_port_r_req_0_transid_set || slv_port_r_req_0_transid_sampled);

// Modeling incoming request for slv_port_r_req_0__2
if (ASSERT_INPUTS) begin
	as__slv_port_r_req_0__2_fairness: assert property (slv_port_r_resp_0__2_val |-> s_eventually(slv_port_r_resp_0__2_rdy));
end else begin
	am__slv_port_r_req_0__2_fairness: assume property (slv_port_r_resp_0__2_val |-> s_eventually(slv_port_r_resp_0__2_rdy));
end

// Generate sampling signals and model
reg [3:0] slv_port_r_req_0__2_transid_sampled;
wire slv_port_r_req_0__2_transid_set = slv_port_r_req_0__2_hsk && slv_port_r_req_0__2_transid == symb_slv_port_r_req_0__2_transid;
wire slv_port_r_req_0__2_transid_response = slv_port_r_resp_0__2_hsk && slv_port_r_resp_0__2_transid == symb_slv_port_r_req_0__2_transid;

always_ff @(posedge clk_i) begin
	if(!rst_ni) begin
		slv_port_r_req_0__2_transid_sampled <= '0;
	end else if (slv_port_r_req_0__2_transid_set || slv_port_r_req_0__2_transid_response ) begin
		slv_port_r_req_0__2_transid_sampled <= slv_port_r_req_0__2_transid_sampled + slv_port_r_req_0__2_transid_set - slv_port_r_req_0__2_transid_response;
	end
end
co__slv_port_r_req_0__2_transid_sampled: cover property (|slv_port_r_req_0__2_transid_sampled);
if (ASSERT_INPUTS) begin
	as__slv_port_r_req_0__2_transid_sample_no_overflow: assert property (slv_port_r_req_0__2_transid_sampled != '1 || !slv_port_r_req_0__2_transid_set);
end else begin
	am__slv_port_r_req_0__2_transid_sample_no_overflow: assume property (slv_port_r_req_0__2_transid_sampled != '1 || !slv_port_r_req_0__2_transid_set);
end


// Assert that if valid eventually ready or dropped valid
//as__slv_port_r_req_0__2_transid_hsk_or_drop: assert property (slv_port_r_req_0__2_val |-> s_eventually(!slv_port_r_req_0__2_val || slv_port_r_req_0__2_rdy));
// Assert that every request has a response and that every reponse has a request
//as__slv_port_r_req_0__2_transid_eventual_response: assert property (|slv_port_r_req_0__2_transid_sampled |-> s_eventually(slv_port_r_resp_0__2_val && (slv_port_r_resp_0__2_transid == symb_slv_port_r_req_0__2_transid) ));
//as__slv_port_r_req_0__2_transid_was_a_request: assert property (slv_port_r_req_0__2_transid_response |-> slv_port_r_req_0__2_transid_set || slv_port_r_req_0__2_transid_sampled);

// Modeling incoming request for slv_port_r_req_1
if (ASSERT_INPUTS) begin
	as__slv_port_r_req_1_fairness: assert property (slv_port_r_resp_1_val |-> s_eventually(slv_port_r_resp_1_rdy));
end else begin
	am__slv_port_r_req_1_fairness: assume property (slv_port_r_resp_1_val |-> s_eventually(slv_port_r_resp_1_rdy));
end

// Generate sampling signals and model
reg [3:0] slv_port_r_req_1_transid_sampled;
wire slv_port_r_req_1_transid_set = slv_port_r_req_1_hsk && slv_port_r_req_1_transid == symb_slv_port_r_req_1_transid;
wire slv_port_r_req_1_transid_response = slv_port_r_resp_1_hsk && slv_port_r_resp_1_transid == symb_slv_port_r_req_1_transid;

always_ff @(posedge clk_i) begin
	if(!rst_ni) begin
		slv_port_r_req_1_transid_sampled <= '0;
	end else if (slv_port_r_req_1_transid_set || slv_port_r_req_1_transid_response ) begin
		slv_port_r_req_1_transid_sampled <= slv_port_r_req_1_transid_sampled + slv_port_r_req_1_transid_set - slv_port_r_req_1_transid_response;
	end
end
co__slv_port_r_req_1_transid_sampled: cover property (|slv_port_r_req_1_transid_sampled);
if (ASSERT_INPUTS) begin
	as__slv_port_r_req_1_transid_sample_no_overflow: assert property (slv_port_r_req_1_transid_sampled != '1 || !slv_port_r_req_1_transid_set);
end else begin
	am__slv_port_r_req_1_transid_sample_no_overflow: assume property (slv_port_r_req_1_transid_sampled != '1 || !slv_port_r_req_1_transid_set);
end


// Assert that if valid eventually ready or dropped valid
//as__slv_port_r_req_1_transid_hsk_or_drop: assert property (slv_port_r_req_1_val |-> s_eventually(!slv_port_r_req_1_val || slv_port_r_req_1_rdy));
// Assert that every request has a response and that every reponse has a request
//as__slv_port_r_req_1_transid_eventual_response: assert property (|slv_port_r_req_1_transid_sampled |-> s_eventually(slv_port_r_resp_1_val && (slv_port_r_resp_1_transid == symb_slv_port_r_req_1_transid) ));
//as__slv_port_r_req_1_transid_was_a_request: assert property (slv_port_r_req_1_transid_response |-> slv_port_r_req_1_transid_set || slv_port_r_req_1_transid_sampled);

// Modeling incoming request for slv_port_r_req_1__2
if (ASSERT_INPUTS) begin
	as__slv_port_r_req_1__2_fairness: assert property (slv_port_r_resp_1__2_val |-> s_eventually(slv_port_r_resp_1__2_rdy));
end else begin
	am__slv_port_r_req_1__2_fairness: assume property (slv_port_r_resp_1__2_val |-> s_eventually(slv_port_r_resp_1__2_rdy));
end

// Generate sampling signals and model
reg [3:0] slv_port_r_req_1__2_transid_sampled;
wire slv_port_r_req_1__2_transid_set = slv_port_r_req_1__2_hsk && slv_port_r_req_1__2_transid == symb_slv_port_r_req_1__2_transid;
wire slv_port_r_req_1__2_transid_response = slv_port_r_resp_1__2_hsk && slv_port_r_resp_1__2_transid == symb_slv_port_r_req_1__2_transid;

always_ff @(posedge clk_i) begin
	if(!rst_ni) begin
		slv_port_r_req_1__2_transid_sampled <= '0;
	end else if (slv_port_r_req_1__2_transid_set || slv_port_r_req_1__2_transid_response ) begin
		slv_port_r_req_1__2_transid_sampled <= slv_port_r_req_1__2_transid_sampled + slv_port_r_req_1__2_transid_set - slv_port_r_req_1__2_transid_response;
	end
end
co__slv_port_r_req_1__2_transid_sampled: cover property (|slv_port_r_req_1__2_transid_sampled);
if (ASSERT_INPUTS) begin
	as__slv_port_r_req_1__2_transid_sample_no_overflow: assert property (slv_port_r_req_1__2_transid_sampled != '1 || !slv_port_r_req_1__2_transid_set);
end else begin
	am__slv_port_r_req_1__2_transid_sample_no_overflow: assume property (slv_port_r_req_1__2_transid_sampled != '1 || !slv_port_r_req_1__2_transid_set);
end


// Assert that if valid eventually ready or dropped valid
//as__slv_port_r_req_1__2_transid_hsk_or_drop: assert property (slv_port_r_req_1__2_val |-> s_eventually(!slv_port_r_req_1__2_val || slv_port_r_req_1__2_rdy));
// Assert that every request has a response and that every reponse has a request
//as__slv_port_r_req_1__2_transid_eventual_response: assert property (|slv_port_r_req_1__2_transid_sampled |-> s_eventually(slv_port_r_resp_1__2_val && (slv_port_r_resp_1__2_transid == symb_slv_port_r_req_1__2_transid) ));
//as__slv_port_r_req_1__2_transid_was_a_request: assert property (slv_port_r_req_1__2_transid_response |-> slv_port_r_req_1__2_transid_set || slv_port_r_req_1__2_transid_sampled);

// Modeling incoming request for slv_port_w_req_0
if (ASSERT_INPUTS) begin
	as__slv_port_w_req_0_fairness: assert property (slv_port_w_resp_0_val |-> s_eventually(slv_port_w_resp_0_rdy));
end else begin
	am__slv_port_w_req_0_fairness: assume property (slv_port_w_resp_0_val |-> s_eventually(slv_port_w_resp_0_rdy));
end

// Generate sampling signals and model
reg [3:0] slv_port_w_req_0_transid_sampled;
wire slv_port_w_req_0_transid_set = slv_port_w_req_0_hsk && slv_port_w_req_0_transid == symb_slv_port_w_req_0_transid;
wire slv_port_w_req_0_transid_response = slv_port_w_resp_0_hsk && slv_port_w_resp_0_transid == symb_slv_port_w_req_0_transid;

always_ff @(posedge clk_i) begin
	if(!rst_ni) begin
		slv_port_w_req_0_transid_sampled <= '0;
	end else if (slv_port_w_req_0_transid_set || slv_port_w_req_0_transid_response ) begin
		slv_port_w_req_0_transid_sampled <= slv_port_w_req_0_transid_sampled + slv_port_w_req_0_transid_set - slv_port_w_req_0_transid_response;
	end
end
co__slv_port_w_req_0_transid_sampled: cover property (|slv_port_w_req_0_transid_sampled);
if (ASSERT_INPUTS) begin
	as__slv_port_w_req_0_transid_sample_no_overflow: assert property (slv_port_w_req_0_transid_sampled != '1 || !slv_port_w_req_0_transid_set);
end else begin
	am__slv_port_w_req_0_transid_sample_no_overflow: assume property (slv_port_w_req_0_transid_sampled != '1 || !slv_port_w_req_0_transid_set);
end


// Assert that if valid eventually ready or dropped valid
//as__slv_port_w_req_0_transid_hsk_or_drop: assert property (slv_port_w_req_0_val |-> s_eventually(!slv_port_w_req_0_val || slv_port_w_req_0_rdy));
// Assert that every request has a response and that every reponse has a request
//as__slv_port_w_req_0_transid_eventual_response: assert property (|slv_port_w_req_0_transid_sampled |-> s_eventually(slv_port_w_resp_0_val && (slv_port_w_resp_0_transid == symb_slv_port_w_req_0_transid) ));
//as__slv_port_w_req_0_transid_was_a_request: assert property (slv_port_w_req_0_transid_response |-> slv_port_w_req_0_transid_set || slv_port_w_req_0_transid_sampled);

// Modeling incoming request for slv_port_w_req_0__2
if (ASSERT_INPUTS) begin
	as__slv_port_w_req_0__2_fairness: assert property (slv_port_w_resp_0__2_val |-> s_eventually(slv_port_w_resp_0__2_rdy));
end else begin
	am__slv_port_w_req_0__2_fairness: assume property (slv_port_w_resp_0__2_val |-> s_eventually(slv_port_w_resp_0__2_rdy));
end

// Generate sampling signals and model
reg [3:0] slv_port_w_req_0__2_transid_sampled;
wire slv_port_w_req_0__2_transid_set = slv_port_w_req_0__2_hsk && slv_port_w_req_0__2_transid == symb_slv_port_w_req_0__2_transid;
wire slv_port_w_req_0__2_transid_response = slv_port_w_resp_0__2_hsk && slv_port_w_resp_0__2_transid == symb_slv_port_w_req_0__2_transid;

always_ff @(posedge clk_i) begin
	if(!rst_ni) begin
		slv_port_w_req_0__2_transid_sampled <= '0;
	end else if (slv_port_w_req_0__2_transid_set || slv_port_w_req_0__2_transid_response ) begin
		slv_port_w_req_0__2_transid_sampled <= slv_port_w_req_0__2_transid_sampled + slv_port_w_req_0__2_transid_set - slv_port_w_req_0__2_transid_response;
	end
end
co__slv_port_w_req_0__2_transid_sampled: cover property (|slv_port_w_req_0__2_transid_sampled);
if (ASSERT_INPUTS) begin
	as__slv_port_w_req_0__2_transid_sample_no_overflow: assert property (slv_port_w_req_0__2_transid_sampled != '1 || !slv_port_w_req_0__2_transid_set);
end else begin
	am__slv_port_w_req_0__2_transid_sample_no_overflow: assume property (slv_port_w_req_0__2_transid_sampled != '1 || !slv_port_w_req_0__2_transid_set);
end


// Assert that if valid eventually ready or dropped valid
//as__slv_port_w_req_0__2_transid_hsk_or_drop: assert property (slv_port_w_req_0__2_val |-> s_eventually(!slv_port_w_req_0__2_val || slv_port_w_req_0__2_rdy));
// Assert that every request has a response and that every reponse has a request
//as__slv_port_w_req_0__2_transid_eventual_response: assert property (|slv_port_w_req_0__2_transid_sampled |-> s_eventually(slv_port_w_resp_0__2_val && (slv_port_w_resp_0__2_transid == symb_slv_port_w_req_0__2_transid) ));
//as__slv_port_w_req_0__2_transid_was_a_request: assert property (slv_port_w_req_0__2_transid_response |-> slv_port_w_req_0__2_transid_set || slv_port_w_req_0__2_transid_sampled);

// Modeling incoming request for slv_port_w_req_1
if (ASSERT_INPUTS) begin
	as__slv_port_w_req_1_fairness: assert property (slv_port_w_resp_1_val |-> s_eventually(slv_port_w_resp_1_rdy));
end else begin
	am__slv_port_w_req_1_fairness: assume property (slv_port_w_resp_1_val |-> s_eventually(slv_port_w_resp_1_rdy));
end

// Generate sampling signals and model
reg [3:0] slv_port_w_req_1_transid_sampled;
wire slv_port_w_req_1_transid_set = slv_port_w_req_1_hsk && slv_port_w_req_1_transid == symb_slv_port_w_req_1_transid;
wire slv_port_w_req_1_transid_response = slv_port_w_resp_1_hsk && slv_port_w_resp_1_transid == symb_slv_port_w_req_1_transid;

always_ff @(posedge clk_i) begin
	if(!rst_ni) begin
		slv_port_w_req_1_transid_sampled <= '0;
	end else if (slv_port_w_req_1_transid_set || slv_port_w_req_1_transid_response ) begin
		slv_port_w_req_1_transid_sampled <= slv_port_w_req_1_transid_sampled + slv_port_w_req_1_transid_set - slv_port_w_req_1_transid_response;
	end
end
co__slv_port_w_req_1_transid_sampled: cover property (|slv_port_w_req_1_transid_sampled);
if (ASSERT_INPUTS) begin
	as__slv_port_w_req_1_transid_sample_no_overflow: assert property (slv_port_w_req_1_transid_sampled != '1 || !slv_port_w_req_1_transid_set);
end else begin
	am__slv_port_w_req_1_transid_sample_no_overflow: assume property (slv_port_w_req_1_transid_sampled != '1 || !slv_port_w_req_1_transid_set);
end


// Assert that if valid eventually ready or dropped valid
//as__slv_port_w_req_1_transid_hsk_or_drop: assert property (slv_port_w_req_1_val |-> s_eventually(!slv_port_w_req_1_val || slv_port_w_req_1_rdy));
// Assert that every request has a response and that every reponse has a request
//as__slv_port_w_req_1_transid_eventual_response: assert property (|slv_port_w_req_1_transid_sampled |-> s_eventually(slv_port_w_resp_1_val && (slv_port_w_resp_1_transid == symb_slv_port_w_req_1_transid) ));
//as__slv_port_w_req_1_transid_was_a_request: assert property (slv_port_w_req_1_transid_response |-> slv_port_w_req_1_transid_set || slv_port_w_req_1_transid_sampled);

// Modeling incoming request for slv_port_w_req_1__2
if (ASSERT_INPUTS) begin
	as__slv_port_w_req_1__2_fairness: assert property (slv_port_w_resp_1__2_val |-> s_eventually(slv_port_w_resp_1__2_rdy));
end else begin
	am__slv_port_w_req_1__2_fairness: assume property (slv_port_w_resp_1__2_val |-> s_eventually(slv_port_w_resp_1__2_rdy));
end

// Generate sampling signals and model
reg [3:0] slv_port_w_req_1__2_transid_sampled;
wire slv_port_w_req_1__2_transid_set = slv_port_w_req_1__2_hsk && slv_port_w_req_1__2_transid == symb_slv_port_w_req_1__2_transid;
wire slv_port_w_req_1__2_transid_response = slv_port_w_resp_1__2_hsk && slv_port_w_resp_1__2_transid == symb_slv_port_w_req_1__2_transid;

always_ff @(posedge clk_i) begin
	if(!rst_ni) begin
		slv_port_w_req_1__2_transid_sampled <= '0;
	end else if (slv_port_w_req_1__2_transid_set || slv_port_w_req_1__2_transid_response ) begin
		slv_port_w_req_1__2_transid_sampled <= slv_port_w_req_1__2_transid_sampled + slv_port_w_req_1__2_transid_set - slv_port_w_req_1__2_transid_response;
	end
end
co__slv_port_w_req_1__2_transid_sampled: cover property (|slv_port_w_req_1__2_transid_sampled);
if (ASSERT_INPUTS) begin
	as__slv_port_w_req_1__2_transid_sample_no_overflow: assert property (slv_port_w_req_1__2_transid_sampled != '1 || !slv_port_w_req_1__2_transid_set);
end else begin
	am__slv_port_w_req_1__2_transid_sample_no_overflow: assume property (slv_port_w_req_1__2_transid_sampled != '1 || !slv_port_w_req_1__2_transid_set);
end


// Assert that if valid eventually ready or dropped valid
//as__slv_port_w_req_1__2_transid_hsk_or_drop: assert property (slv_port_w_req_1__2_val |-> s_eventually(!slv_port_w_req_1__2_val || slv_port_w_req_1__2_rdy));
// Assert that every request has a response and that every reponse has a request
//as__slv_port_w_req_1__2_transid_eventual_response: assert property (|slv_port_w_req_1__2_transid_sampled |-> s_eventually(slv_port_w_resp_1__2_val && (slv_port_w_resp_1__2_transid == symb_slv_port_w_req_1__2_transid) ));
//as__slv_port_w_req_1__2_transid_was_a_request: assert property (slv_port_w_req_1__2_transid_response |-> slv_port_w_req_1__2_transid_set || slv_port_w_req_1__2_transid_sampled);

assign slv_port_r_req_0_val = slv_ports_req_i[0].ar_valid;
assign slv_port_r_req_0__2_val = slv_ports_req_i_2[0].ar_valid;
assign slv_port_r_req_0_rdy = slv_ports_resp_o[0].ar_ready;
assign slv_port_r_req_0__2_rdy = slv_ports_resp_o_2[0].ar_ready;
assign slv_port_r_req_0_transid = slv_ports_req_i[0].ar.id;
assign slv_port_r_req_0__2_transid = slv_ports_req_i_2[0].ar.id;
assign slv_port_r_resp_0_val = slv_ports_resp_o[0].r_valid && slv_ports_resp_o[0].r.last;
assign slv_port_r_resp_0__2_val = slv_ports_resp_o_2[0].r_valid && slv_ports_resp_o_2[0].r.last;
assign slv_port_r_resp_0_rdy = slv_ports_req_i[0].r_ready;
assign slv_port_r_resp_0__2_rdy = slv_ports_req_i_2[0].r_ready;
assign slv_port_r_resp_0_transid = slv_ports_resp_o[0].r.id;
assign slv_port_r_resp_0__2_transid = slv_ports_resp_o_2[0].r.id;
assign slv_port_r_req_1_val = slv_ports_req_i[1].ar_valid;
assign slv_port_r_req_1__2_val = slv_ports_req_i_2[1].ar_valid;
assign slv_port_r_req_1_rdy = slv_ports_resp_o[1].ar_ready;
assign slv_port_r_req_1__2_rdy = slv_ports_resp_o_2[1].ar_ready;
assign slv_port_r_req_1_transid = slv_ports_req_i[1].ar.id;
assign slv_port_r_req_1__2_transid = slv_ports_req_i_2[1].ar.id;
assign slv_port_r_resp_1_val = slv_ports_resp_o[1].r_valid && slv_ports_resp_o[1].r.last;
assign slv_port_r_resp_1__2_val = slv_ports_resp_o_2[1].r_valid && slv_ports_resp_o_2[1].r.last;
assign slv_port_r_resp_1_rdy = slv_ports_req_i[1].r_ready;
assign slv_port_r_resp_1__2_rdy = slv_ports_req_i_2[1].r_ready;
assign slv_port_r_resp_1_transid = slv_ports_resp_o[1].r.id;
assign slv_port_r_resp_1__2_transid = slv_ports_resp_o_2[1].r.id;
assign slv_port_w_req_0_val = slv_ports_req_i[0].aw_valid;
assign slv_port_w_req_0__2_val = slv_ports_req_i_2[0].aw_valid;
assign slv_port_w_req_0_rdy = slv_ports_resp_o[0].aw_ready;
assign slv_port_w_req_0__2_rdy = slv_ports_resp_o_2[0].aw_ready;
assign slv_port_w_req_0_transid = slv_ports_req_i[0].aw.id;
assign slv_port_w_req_0__2_transid = slv_ports_req_i_2[0].aw.id;
assign slv_port_w_resp_0_val = slv_ports_resp_o[0].b_valid;
assign slv_port_w_resp_0__2_val = slv_ports_resp_o_2[0].b_valid;
assign slv_port_w_resp_0_rdy = slv_ports_req_i[0].b_ready;
assign slv_port_w_resp_0__2_rdy = slv_ports_req_i_2[0].b_ready;
assign slv_port_w_resp_0_transid = slv_ports_resp_o[0].b.id;
assign slv_port_w_resp_0__2_transid = slv_ports_resp_o_2[0].b.id;
assign slv_port_w_req_1_val = slv_ports_req_i[1].aw_valid;
assign slv_port_w_req_1__2_val = slv_ports_req_i_2[1].aw_valid;
assign slv_port_w_req_1_rdy = slv_ports_resp_o[1].aw_ready;
assign slv_port_w_req_1__2_rdy = slv_ports_resp_o_2[1].aw_ready;
assign slv_port_w_req_1_transid = slv_ports_req_i[1].aw.id;
assign slv_port_w_req_1__2_transid = slv_ports_req_i_2[1].aw.id;
assign slv_port_w_resp_1_val = slv_ports_resp_o[1].b_valid;
assign slv_port_w_resp_1__2_val = slv_ports_resp_o_2[1].b_valid;
assign slv_port_w_resp_1_rdy = slv_ports_req_i[1].b_ready;
assign slv_port_w_resp_1__2_rdy = slv_ports_req_i_2[1].b_ready;
assign slv_port_w_resp_1_transid = slv_ports_resp_o[1].b.id;
assign slv_port_w_resp_1__2_transid = slv_ports_resp_o_2[1].b.id;

//====DESIGNER-ADDED-SVA====//

  // ASSUME 1: We are never in testmode
  no_testmode: assume property (test_i == 1'b0);

  // ASSUME 2: We have a legal address map
  for (genvar i = 0; i < Cfg.NoAddrRules; i++) begin : legal_address_map
    // Each address rule needs to be increasing (end address higher than start address)
    am_pos_range: assume property (addr_map_i[i].end_addr > addr_map_i[i].start_addr);
    // Each address rule must not overlap with any other address rule
    for (genvar j = 0; j < Cfg.NoAddrRules; j++) begin : am_non_overlapping
      if (i != j) begin : am_non_overlapping_other
        am_no_overlap: assume property (addr_map_i[i].end_addr <= addr_map_i[j].start_addr ||
                                        addr_map_i[i].start_addr >= addr_map_i[j].end_addr);
      end
    end
  end

  // ASSUME 3: There is no valid request during context switch
  logic any_valid;
  always_comb begin : no_valid
    any_valid = 1'b0;
    for (int i = 0; i < Cfg.NoSlvPorts; i++) begin
      if (slv_ports_req_i[i].ar_valid || slv_ports_req_i[i].aw_valid || slv_ports_req_i[i].w_valid || slv_ports_resp_o[i].r_valid || slv_ports_resp_o[i].b_valid ||
          slv_ports_req_i_2[i].ar_valid || slv_ports_req_i_2[i].aw_valid || slv_ports_req_i_2[i].w_valid || slv_ports_resp_o_2[i].r_valid || slv_ports_resp_o_2[i].b_valid)
        any_valid = 1'b1;
    end
  end

  // ASSUME 4: There are no outstanding transactions during context switch (transaction-level)
  // Count outstanding transactions
  reg [1:0][Cfg.NoSlvPorts-1:0][$clog2(Cfg.MaxMstTrans):0] r_cnt_d, r_cnt_q, w_cnt_d, w_cnt_q;

  for (genvar i = 0; i < Cfg.NoSlvPorts; i++) begin : count_outstanding
    assign r_cnt_d[0][i] = r_cnt_q[0][i] + (slv_ports_req_i[i].ar_valid && slv_ports_resp_o[i].ar_ready) -
                           (slv_ports_resp_o[i].r_valid && slv_ports_req_i[i].r_ready && slv_ports_resp_o[i].r.last);
    assign r_cnt_d[1][i] = r_cnt_q[1][i] + (slv_ports_req_i_2[i].ar_valid && slv_ports_resp_o_2[i].ar_ready) -
                           (slv_ports_resp_o_2[i].r_valid && slv_ports_req_i_2[i].r_ready && slv_ports_resp_o_2[i].r.last);
    assign w_cnt_d[0][i] = w_cnt_q[0][i] + (slv_ports_req_i[i].aw_valid && slv_ports_resp_o[i].aw_ready) -
                           (slv_ports_resp_o[i].b_valid && slv_ports_req_i[i].b_ready);
    assign w_cnt_d[1][i] = w_cnt_q[1][i] + (slv_ports_req_i_2[i].aw_valid && slv_ports_resp_o_2[i].aw_ready) -
                           (slv_ports_resp_o_2[i].b_valid && slv_ports_req_i_2[i].b_ready);
  end

  logic any_outstanding;
  always_comb begin : comb_any_outstanding
    any_outstanding = 1'b0;
    for (int i = 0; i < 2; i++) begin
      for (int j = 0; j < Cfg.NoSlvPorts; j++) begin
        if (r_cnt_q[i][j] != '0 || w_cnt_q[i][j] != '0) any_outstanding = 1'b1;
      end
    end
  end

  always_ff @(posedge clk_i) begin
    if (!rst_ni) begin
      r_cnt_q <= 0;
      w_cnt_q <= 0;
    end else begin
      r_cnt_q <= r_cnt_d;
      w_cnt_q <= w_cnt_d;
    end
  end

  // ASSUME 6: AXI handshake stability rules
  for (genvar i = 0; i < Cfg.NoSlvPorts; i++) begin : slv_stable
    slv_ar_stable: assume property ((slv_ports_req_i[i].ar_valid && !slv_ports_resp_o[i].ar_ready) |=> (slv_ports_req_i[i].ar_valid && $stable(slv_ports_req_i[i].ar)));
    slv_ar_stable_2: assume property ((slv_ports_req_i_2[i].ar_valid && !slv_ports_resp_o_2[i].ar_ready) |=> (slv_ports_req_i_2[i].ar_valid && $stable(slv_ports_req_i_2[i].ar)));
    slv_aw_stable: assume property ((slv_ports_req_i[i].aw_valid && !slv_ports_resp_o[i].aw_ready) |=> (slv_ports_req_i[i].aw_valid && $stable(slv_ports_req_i[i].aw)));
    slv_aw_stable_2: assume property ((slv_ports_req_i_2[i].aw_valid && !slv_ports_resp_o_2[i].aw_ready) |=> (slv_ports_req_i_2[i].aw_valid && $stable(slv_ports_req_i_2[i].aw)));
    slv_w_stable: assume property ((slv_ports_req_i[i].w_valid && !slv_ports_resp_o[i].w_ready) |=> (slv_ports_req_i[i].w_valid && $stable(slv_ports_req_i[i].w)));
    slv_w_stable_2: assume property ((slv_ports_req_i_2[i].w_valid && !slv_ports_resp_o_2[i].w_ready) |=> (slv_ports_req_i_2[i].w_valid && $stable(slv_ports_req_i_2[i].w)));
    // Some correctness checks won't hurt...
    //slv_r_stable: assert property ((slv_ports_resp_o[i].r_valid && !slv_ports_req_i[i].r_ready) |=> (slv_ports_resp_o[i].r_valid && $stable(slv_ports_resp_o[i].r)));
    //slv_r_stable_2: assert property ((slv_ports_resp_o_2[i].r_valid && !slv_ports_req_i_2[i].r_ready) |=> (slv_ports_resp_o_2[i].r_valid && $stable(slv_ports_resp_o_2[i].r)));
    //slv_b_stable: assert property ((slv_ports_resp_o[i].b_valid && !slv_ports_req_i[i].b_ready) |=> (slv_ports_resp_o[i].b_valid && $stable(slv_ports_resp_o[i].b)));
    //slv_b_stable_2: assert property ((slv_ports_resp_o_2[i].b_valid && !slv_ports_req_i_2[i].b_ready) |=> (slv_ports_resp_o_2[i].b_valid && $stable(slv_ports_resp_o_2[i].b)));
  end

  // ASSUME 7: No decode errors
  for (genvar i = 0; i < Cfg.NoSlvPorts; i++) begin : slv_no_err
    slv_no_ar_err_1: assume property (u_axi_xslv.i_axi_xbar.i_xbar_unmuxed.gen_slv_port_demux[i].dec_ar_error == 1'b0);
    slv_no_ar_err_2: assume property (u_axi_xslv2.i_axi_xbar.i_xbar_unmuxed.gen_slv_port_demux[i].dec_ar_error == 1'b0);
    slv_no_aw_err_1: assume property (u_axi_xslv.i_axi_xbar.i_xbar_unmuxed.gen_slv_port_demux[i].dec_aw_error == 1'b0);
    slv_no_aw_err_2: assume property (u_axi_xslv2.i_axi_xbar.i_xbar_unmuxed.gen_slv_port_demux[i].dec_aw_error == 1'b0);
  end

  // ASSUME 8: No open Ws
  logic any_open_w;
  always_comb begin: no_open
    any_open_w = 1'b0;
    //for (int i = 0; i < Cfg.NoSlvPorts; i++) begin : slv_no_open_w
      //any_open_w |= |u_axi_xslv.i_axi_xbar.i_xbar_unmuxed.gen_slv_port_demux[i].i_axi_demux.i_demux_simple.genblk1.w_open;
      //any_open_w |= |u_axi_xslv2.i_axi_xbar.i_xbar_unmuxed.gen_slv_port_demux[i].i_axi_demux.i_demux_simple.genblk1.w_open;
    //end
    any_open_w |= |u_axi_xslv.i_axi_xbar.i_xbar_unmuxed.gen_slv_port_demux[0].i_axi_demux.i_demux_simple.genblk1.w_open;
    any_open_w |= |u_axi_xslv2.i_axi_xbar.i_xbar_unmuxed.gen_slv_port_demux[0].i_axi_demux.i_demux_simple.genblk1.w_open;
    any_open_w |= |u_axi_xslv.i_axi_xbar.i_xbar_unmuxed.gen_slv_port_demux[1].i_axi_demux.i_demux_simple.genblk1.w_open;
    any_open_w |= |u_axi_xslv2.i_axi_xbar.i_xbar_unmuxed.gen_slv_port_demux[1].i_axi_demux.i_demux_simple.genblk1.w_open;
  end
  slv_eventually_no_open_w: assume property (any_open_w |-> s_eventually(!any_open_w));

  // ASSUME 9: No atomics (for now). They trigger two responses (R and B), which might actually be interesting
  for (genvar i = 0; i < Cfg.NoSlvPorts; i++) begin : slv_no_atop
    slv_no_atop_1: assume property (slv_ports_req_i[i].aw.atop == '0);
    slv_no_atop_2: assume property (slv_ports_req_i_2[i].aw.atop == '0);
  end

  // ASSUME 10: Legal W beats
  logic [1:0][Cfg.NoSlvPorts-1:0] w_open;
  for (genvar i = 0; i < Cfg.NoSlvPorts; i++) begin : gen_slv_w_bst_legal_slv_port
    slv_req_t [1:0] req;
    slv_resp_t [1:0] resp;
    assign req = {slv_ports_req_i_2[i], slv_ports_req_i[i]};
    assign resp = {slv_ports_resp_o_2[i], slv_ports_resp_o[i]};
    for (genvar j = 0; j < 2; j++) begin : gen_slv_w_bst_legal_universe
      logic [$clog2(256):0] w_len, w_cnt;
      logic w_fifo_empty, w_xfer;
      assign w_xfer = ((w_cnt == 1'b1 & req[j].w_valid & resp[j].w_ready) | w_cnt == '0) & !w_fifo_empty;
      assign w_open[j][i] = |w_cnt | !w_fifo_empty;
      fifo_v3 #(
        .FALL_THROUGH(1),
        .DATA_WIDTH($clog2(256)+1),
        .DEPTH(Cfg.MaxMstTrans)
      ) i_w_fifo (
        .clk_i,
        .rst_ni,
        .flush_i(1'b0),
        .testmode_i(1'b0),
        .full_o(),
        .empty_o(w_fifo_empty),
        .usage_o(),
        .data_i(req[j].aw.len + 1),
        .push_i(req[j].aw_valid & resp[j].aw_ready),
        .data_o(w_len),
        .pop_i(w_xfer)
      );
      counter #(
        .WIDTH($clog2(256)+1)
      ) i_w_cnt (
        .clk_i,
        .rst_ni,
        .clear_i(1'b0),
        .en_i(req[j].w_valid & resp[j].w_ready),
        .load_i(w_xfer),
        .down_i(1'b1),
        .d_i(w_len),
        .q_o(w_cnt),
        .overflow_o()
      );
      slv_only_open_w: assume property (req[j].w_valid |-> w_cnt != '0);
      slv_w_last: assume property (req[j].w_valid |-> (w_cnt > 'b1) ^ req[j].w.last);
      slv_eventually_close_w: assume property (w_cnt != '0 |-> s_eventually(w_cnt == '0));
    end
  end

  // ASSUME 11: Always incremental bursts
  for (genvar i = 0; i < Cfg.NoSlvPorts; i++) begin : slv_always_incr
    slv_always_incr_aw_1: assume property (slv_ports_req_i[i].aw.burst == axi_pkg::BURST_INCR);
    slv_always_incr_aw_2: assume property (slv_ports_req_i_2[i].aw.burst == axi_pkg::BURST_INCR);
    slv_always_incr_ar_1: assume property (slv_ports_req_i[i].ar.burst == axi_pkg::BURST_INCR);
    slv_always_incr_ar_2: assume property (slv_ports_req_i_2[i].ar.burst == axi_pkg::BURST_INCR);
  end

  // ASSUME 12: After valid eventually ready
  for (genvar i = 0; i < Cfg.NoSlvPorts; i++) begin : slv_valid_eventually_ready
    slv_valid_eventually_ready_r_1: assume property (slv_ports_resp_o[i].r_valid |-> s_eventually(slv_ports_req_i[i].r_ready));
    slv_valid_eventually_ready_r_2: assume property (slv_ports_resp_o_2[i].r_valid |-> s_eventually(slv_ports_req_i_2[i].r_ready));
    slv_valid_eventually_ready_b_1: assume property (slv_ports_resp_o[i].b_valid |-> s_eventually(slv_ports_req_i[i].b_ready));
    slv_valid_eventually_ready_b_2: assume property (slv_ports_resp_o_2[i].b_valid |-> s_eventually(slv_ports_req_i_2[i].b_ready));
  end

  assign architectural_state_eq = !any_outstanding && !any_valid && !any_open_w && w_open == '0;
  assign flush_done = 1'b1;

endmodule
